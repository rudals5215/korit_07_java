# 수업 내용을 작성하는 영역으로 사용 예정
.md의 의미 - markdown을 의미합니다. (문서작성법)
## 금일 복습 목록
- 목록
    1. Java
        1. Java의 정의
        2. Java 언어의 개발 배경
        3. 특징
    2. starting (시작)
        1. intellij 패키지 생성  
    3. variable (변수)
        1. 주석(comment)
        2. 변수
        3. 자료형
    4. operator(연산자)
    5. scanner (입력 처리 도구)
    6. conversion (변환)
    7. github
        1. github intellij 연동
        2. github에 등록(잔디심기)

    
# java
## 정의

객체 지향 프로그래밍(OOP : Object-Oriented Programming) 언어, write Once,
Run Anywhere 라는 철학을 바탕으로 다양한 플랫폼에서 실행될 수 있도록 함.
기본적으로 자바 가상머신 (JVM: Java Virtual Machine)을 통해 프로그램이 실행되며
이로 인해 운영 체제나 하드웨어의 차이에도 관계없이 일관된 실행환경을 제공합니다.

그래서 web 개발을 포함한 다양한 분야에서 사용되며,
저희는 수업중 Web 개발 분야에 응요하기 위해 Java를 배울 예정입니다.

## Java 언어의 개발 배경

호환성과  이식성을 극대화하기 위해 개발됨. 90년대 초반에 운영체제의 다양화가 
급격하게 진행되었고, 개발자들은 특정 하드웨어나 OS에 종속되지 않는 프로그램을 
작성하려는 필요성을 느끼게 되었습니다. 이를 해결하기 위해 하나의 코드로
다양한  시스템에서  실행될 수 있는 언어를 만들기로 하였고, Java는 이러한 요구를 
해결하기 위해서 설계 되었습니다.

그래서 Java 관련 시험 문제 중에 '플랫폼 독립성' 이라는 표현이 자주 등장합니다
(3년제 졸 이상 - 정보처리기사/ 2,3년제 졸 이상 -정보처리 산업기사/
고등학교 졸 이상 - 정보처리 기능사 시험시 특히).
운영체제에 관계없이 모든 플랩폼에서 실행될 수  있다는점에서 큰 이점.
이는 Java가 컴파일되어 바이트코드로 변화된 후에 JVM에서  실행되기 때문.

## 특징
1. OOP의 특징 : 프로그램을 '객체'라는  독립정인 단위로  구성하여  문제를 해결.
   객체는 상태(state)와 동작(behavior) 을 가질 수 있으며, 코드의 재사용성, 
   유지보수 용이성, 확장성을 높여줍니다. Java에서는 모든 코드가 클래스 내에서  
   정의되고, 객체를 생성하는  '틀'을 제공합니다.
2. 플랫폼 독립성
3. 자동 메모리 관리 : Java는 garbage collection 기능을 내장하고 있어,
    개발자가 메모리 관리에 신경을  쓰지  않아도 됩니다.  JVM은 사용되지 않은
    객체를 자동으로  메모리에서 해제하여ㅡ 메모리  누수 문제를 최소화합니다.
4. 멀티스레드 지원 : 동시에 여러  작업을 처리할 수 있도록 해주며, 자원의  낭비를
   줄이고 성능을  향상시킵니다. 이는 대규모 애플리케이션이나 네트워크 서버 개발에
    특이 유용합니다.

md파일에서 코드블럭 작성법 : 1 왼쪽에 있는 이상하게 꺾인 작은 따옴표가 있는데
이를 '백틱'이라고 합니다 백틱 세번 누르고  자동 언어를 적어주면
코드를 작성할 수 있습니다.(자동완성도 지원합니다)
```java
public static void main(String[] args){
    System.out.println("Hello, Java!");
}
```

# starting
## intellij 패키지 생성

폴더를 만드는 것을 Java 프로그램 내에서는 패키지라는 표현을 씁니다.
package 생성 원칙 - 소문자로 작성합니다.
file을 만드는 것을 Java프로그램 내에서는 클래스라는 표현을 씁니다.
class 생성 원칙 - 대문자로 시작합니다.

java폴더 우클릭 -> new(새로만들기) -> 패키지
ch01_starting
ch01_starting 우클릭 -> 새로만들기 -> Java class 클릭
Main

# variable (변수)

## 주석(comment)
Java 프로그램의 경우 폴더 및 파일의 전체 코드를 컴파일링하는데,
거기서 오류가 하나라도 발생하게 되면 저체 프로그램이 실행 X
하지만 주석 처리를 한 부분에 대해서는 컴퓨터가 코드로 인지하기 않기 때문에
오류가 발생하지 않습니다

즉 주석이란 컴퓨터가 읽어서 처리하는 부분이 아니라 사람이 읽어서 정보를
얻을 수 있는 데에 의의가 있습니다.

1) 한줄 주석 : //
2) 다중 주석 : / + shift + 8 + enter
3) 사후 주석 : 주석 처리할 부분 코드라인에 ctrl + /

## 변수
```java
public static void main(String[] args) {
    System.out.println("안녕하세요, 제이름은 이경민입니다.");
    System.out.println(1);
    System.out.println('1');
    System.out.println("1");    
}
```
이상과 같은 방식의 코드 대입을(매번 데이터를 직접 사용하는 방식) 하드코딩이라는 표현을 씁니다.
하드코딩 : 명령문에 데이터(변수에 대입되지 않은 데이터인데 이를 리터럴(Literal))를 바로 집어넣는 것으로, '지양'되는 방식.

그렇다면 권장되는 방식은 ? 데이터를 '변수'에 대입하고 변수를 통해서 명령을 내리는 방식

변수(variable) : 데이터를 담는 바구니 -> 이름을 달아줘야 함.
변수 선언 방법 : 자료형 변수명 = 데이터;
변수는 값이 바뀔 수 있음.
재대입할 때는 자료형 명시 X
```java
public static void main(String[] args) {
    int scoreEnglish = 100;                 // 변수 선언 및 초기화
    System.out.println(scoreEnglish);       // sout -> 출력문
    int koreanScore;                        // 변수 선언
    koreanScore = 99;                       // 초기화

    String introduction = "안녕하세요, 저는 이번 국비과정을 하게 된 이경민 입니다.";
    System.out.println(introduction + ". 앞으로 잘 부탁드립니다."); 
//-> 안녕하세요, 저는 이번 국비과정을 하게 된 이경민 입니다. 앞으로 잘 부탁드립니다.
            System.out.println(scoreEnglish); //  => 100
    scoreEnglish = 90;                       // 재대입할 때는 자료형 명시 X
    System.out.println(scoreEnglish);       // => 90
}
```
## 자료형 

1. 논리 자료형(boolean) 변수 : 참/ 거짓 (true/false)
자료형 변수명 = 데이터 (값);   ->  변수의 선언 및 초기화
- boolean checkFlag = false;
checkFlag = true;    -> 재대입

2. 문자 자료형 변수 (char)
```java
public static void main(String[] args) {
    char name1 = '이';
    char name2 = '경';
    char name3 = '민';
    System.out.println(name1 + name2 + name3);  // 결과값 : 143405
    System.out.println('이'+'경'+'민');          // 결과값 : 143405
    System.out.println(""+name1+name2+name3);   // 결과값 : 이경민   
}
```
이상의 코드에서 알 수 있는 점은 컴퓨터가 생각보다 멍청하다.
개발자인 저희가 하나하나 지정을 해줘야 한다는 점입니다.
'문자'와 '문자열'은 서로 다른 개념인데.
문자(하나짜리)를 세번 더했을 경우에는 더이상 문자가 아니라 문자열로 인식되기
떄문에 원하는 방식으로 출력되지 않습니다 144어쩌고로 출력됐죠.

그렇기 때문에 sout()의 ()내부에 ""를 넣어주니까, 원하는 결과값을 얻을 수 있었습니다.

즉,
작은 따옴표('')는 '문자'를 표시하기 위한 기호
큰 따옴표("")는 "문자열"을 표시하기 위한 기호
라고 알아두면 되겠습니다(근데 python이랑 JavaScript에서는 또 이런 구분이 없습니다.)

그리고 sout()의 ()내부에서 가장 먼저 나온 데이터의 자료형을 따라간다는 점도 확인할 수 있습니다.

현재 개념 : 하나짜리 문자가 여러개 모이면 문자열
char : 문자
String : 문자열

ex)
```java
public static void main(String[] args) {
    char name4 = '김';
    String name5 = "철수";

    System.out.println(123 + 1);          // 결과값 : 124
    System.out.println("123" + 1);        // 결과값 : 1231
    System.out.println(123 + "1");        // 결과값 : 1231 근데 얘가 예외적입니다.
}
```

3. 정수 자료형 변수 (int)
```java
public static void main(String[] args) {
    int width1 = 100;
    int width2 = 200;
    System.out.println(width1 + width2);    // 숫자 변수는 연산이 가능합니다.
    String width3 = "300";
    String width4 = "400";
    System.out.println(width3 + width4);    // 300400
//    문자열은 연산이 아니라 "나열"됩니다. 문자열은 '순서'가 중요합니다.
    Integer width5 = 500;
    Integer width6 = 600;
    System.out.println(width5 + width6);    // 근데 문자로 시작하는 Integer가 있긴 합니다.
}
```

4. 실수 자료형 변수 double
```java
double pi = 3.1415926;
int pi = 3.14;        // 오류 발생(소숫점이 있기 때문에 정수가 아님)
```
정수/ 실수 자료형은 수학 연산이 가능합니다.

enter 키 위에 원화 표시 있습니다. 원화 표시가 한국에서만 먹힌는 형태고 원래는 역슬러시만 표기되어 있습니다.
\n -> 개행이 일어납니다.
\t -> 탭 친 효과가 일어납니다.

## Java에서의 변수 명명 규칙 

1. 카멜 표기법 (camel case) 사용 : 첫 문자는 소문자로 시작/ 복수의 단어로 이루어졌을 경우 두번째 단어의 첫번째 문자만 대문자\
    ex) 한 단어 짜리 : result\
    ex) 복수 단어 : myTestResult
2. 특수문자 지양

cf) python 학습하신 분들의 경우 python 변수 표기 방식은 스네이크 표기법(snake case)라고 해서
my_test_result와 같은 방식으로 작성합니다.

Camel case -> Java 상에서의 변수 표기법 (JS에서도 씁니다)
Snake case -> 얘는 뭐 Java에서 쓸 일이 없습니다. 근데 전체 상수 사용 시에 비슷한 표기법이 적용됩니다.
Pascal case -> 첫 번째 문자가 대문자고 나머지는 소문자로 가다가 두 번째 단어의 첫 번째 문자는 또 대문자
ex) 한 단어 짜리 : Operator01
ex) 복수 단어 : OperatorTestResult          -> Pascal Case 는 클래스 명명 규칙에 해당합니다.

# operater(연산자)

- 대입 연산 
= : = 왼쪽과 오른쪽이 같다는 의미가 아니라
= 오른쪽에 있는 데이터를 = 왼쪽에 있는 변수에 '대입'한다는 의미입니다.

그렇다면 왼쪽과 오른쪽이 같은 값이다, 라고 표시할 때는 어떻게 할까요?
== (Java, python)
=== (JavaScript)
```java
public static void main(String[] args) {
    int a=5;        // int는 정수였죠
    int b=2;        // 변수 선언 및 초기화
    double result = (double) a / b;     // (double)은 강제'형변환' 개념입니다.
    System.out.println(a/b);        // 근데 2가 나오죠
    System.out.println(result);     // 얘는 2.5가 나오죠
}
```
그래서 생각보다 코딩 할 때도 얘네가 멍청해서 하나하나 잘 지정해야 합니다.
즉, 개발자는 뭐다? 컴퓨터가 잘 작동할 수 있도록 잘 명령을 내리는 사람이다 라고 생각해 주시고 좀 어르고 달래고 해야합니다.

- 일반 연산자
```
+ : 더하기
- : 빼기
* : 곱하기
/ : 나누기
% : 나머지
그렇다면 나머지 연산의 결과값의 자료형은 무엇이어야만 하는가? -> int
```
- 복합 대입 연산자
```
1) +=
2) -=
3) *=
4) /=
```
- 증감 연산자
```
1. 변수명++ : 코드를 실행시킨 후에 변수에 1을 더함.
2. ++변수명 : 코드를 실행시키기 전에 변수에 1을 더함.
3. 변수명-- : 코드를 실행시킨 후에 변수에 1을 감함.
4. --변수명 : 코드를 실행시키기 전에 변수에 1을 감함.
```
- 논리 연산자
```
true(1) / false(0) : 컴퓨터가 읽을 수 있는 두 숫자
boolean : true / false 를 구분하는 자료형

AND(&&) : 곱 연산자 T X T = T/ T X F = F / F X F = F => 하나라도 false면 false
OR (||) : 합 연산자 T X T = T/ T X F = T / F X F = F => 하나라도 true면 true
NOT(!)  : true 값을 false로, false 값을  true로 역선시키는 연산자
```

# scanner (입력 처리 도구)
```java
public static void main(String[] args) {
    // 변수 선언
    String name;
    name = "이경민";
    System.out.println(name);
    Scanner scanner = new Scanner(System.in);
    System.out.print("이름을 입력하세요 >>> ");
    name = scanner.nextLine();
        /*
            1. println과 print의 차이
                ln : lint new -> println으로 실행되면 출력문이 다 나오면 자동으로 개행됨.
                print로 작성할 경우에 동일 라인에 그대로 연결됨.
            2. nextLine/ nextInt / 어쩌고저쩌고 이런것들이 있다 구분해야겠다
         */
    System.out.print("연도를 입력하세요. >>> ");
    int year = scanner.nextInt();
    System.out.print("이름을 다시 입력하세요 >>> ");
    name = scanner.next();      // 입력을 lee kyeongmin
    System.out.println(name);
        /*
            2. next(Int / Double,... etc)  vs nextLine
                - nextLint은 띄어쓰기를 허용합니다. enter키, 즉 개행을 기준으로 데이터가 변수에 저장됨
                -> 그래서  24번 라인 실행결과가 lee이었습니다.
                - 나머지는 허용 안합니다. 띄어쓰기 하면 잘려서 대입됩니다.
         */
    System.out.print("올해는 몇 년도 인가요? >>> ");
    int year1 = scanner.nextInt();
    System.out.println("당신의 이름은? >>> ");
    String name1 = scanner.nextLine();          // 34번 라인
    System.out.println("연도 : " + year1);
    System.out.println("이름 : " + name1);

        /*
            이상의 코드에서의 문제점은 34번 라인이 실행됐을 때 데이터를 입력받지 않고
            그대로 넘어간다는 점입니다.
            왜 이런 문제가 생기냐면 nextInt()에서 값을 입력하고 저희가 enter를 치게 되는데,
            그 경우 다음 nextLine()에서는 enter키를 받아들여서 빈 값인 상태로 enter를 쳤다고
            인지되기 때문에
            곧장 35번 출력문으로 넘어갔기 때문입니다.

            해결방법 : enter 키를 받아주는 nextLine()를 하나 더 만들어 줍니다.
         */

    System.out.print("올해는 몇 년도 인가요? >>> ");
    int year2 = scanner.nextInt();

    scanner.nextLine();         // 배리어 역할을 하는 nextLine()
    // 얘는 사용되지 않을거니까 변수에 대입하지 않았습니다.

    System.out.print("당신의 이름은? >>> ");
    String name2 = scanner.nextLine();
    System.out.println("연도 : " + year2);
    System.out.println("이름 : " + name2);
}
```
# conversion (변환)

## upcasting(업캐스팅) : 더 큰 용량의 자료형으로 변환시키는것
```java
 public static void main(String[] args) {
        // 변수 선언 및 초기화
        // 자료형 변수명 = 값;
        char cast1 = 'A';
        // 업캐스팅 방법 # 1
        // 형 변환을 하기 위해서는 '(바꿀 데이터타입) 변수명' 으로 작성하시면 됩니다.
        System.out.println("원형 : " +cast1);
        System.out.println("변형 : "+ (int)cast1);        // A를 int로 형변환 시 65(시험에 나옴)

        char cast2 = 'a';
        System.out.println("원형 : "+ cast2);
        System.out.println("변형 : "+ (int)cast2);        // a는 97(외우세요)

        // 업캐스팅 방법 # 2
        // 새로운 변수를 선언하여 캐스팅이 이루어진 데이터를 집어넣는 방법입니다.
        char cast3 = 'b';
        int casted3 = cast3;        // 여기서는 (int)로 안쓰였죠.
        // 대신 위를 보시면 변수를 선언할 때의 자료형이 변환되기를 원하는 자료형으로 명시해 줍니다.
        System.out.println("원형 : "+ cast3);
        System.out.println("변형 : "+ casted3);

        // 다운캐스팅 : 용량이 더 작은 자료형으로 변형하는 것을 의미
        int cast4 = 99;         // 얘는 #1으로,
        int cast5 = 100;        // 얘는 # 2로

        // 다운캐스팅 방벙 # 1
        System.out.println("원형 : " + cast4);
        System.out.println("변형 : " + (char) cast4);

        // 다운캐스팅 방법 # 2
        char casted5 = cast5;   // 38번 라인
/*
    현재 38번 코드 라인에서 오류가 발생하는 것은 정상입니다.
    추후 수업에서 더 중요하게 적용되는 개념인데, upcasting의 경우에는 메모리 용량이 커지면
    되니까 기존 데이터가 변형이 일어날 가능성이 없어서 임시적(implicit)으로 변형이 가능한 반면.
    downcasting의 경우에는 데이터 용량이 축소되는 과정에서 변수가 메모리 용량을 벗어나게 되는
    경우가 있습니다
    (아까 강남스타일을 예시로 들었을때 20억 넘는 숫자를 다시 int로 형변환하게 되면 마이너스 값이 나오게 되겠죠)
    용량 오버에 해당하는 현상을 미리 점검하기 위해 다운캐스팅 시에는
    명시적(explicit)으로만 변형이 가능합니다.

    -> 현재는 기본 자료형을 기준으로 예시를 들었지만 나중에는 참조자료형 캐스팅 개념과 연결됩니다.
 */
        char casted5 = (char)cast5;
        System.out.println("원형 : " + cast5);
        System.out.println("변형 : " + casted5);
    }
```
int가 21억 정도까지의 범위인데 더 큰 숫자로 표기하기 위해서는
정수 기준으로 long을 사용 -> SQL 문에서는 그 와중에 long이 아니면 bigint라고 씁니다.

# github 
## github intellij 연동
chrome 에서 github 검색 -> sign up 하세요
현재 Repository 생성까지 처리

window + 자격증명 -> github.com 삭제(사용중인 깃허브 사용자 제거)

git init - 초기화
git config user.name "깃허브 아이디"
git config user.email "깃허브 이메일"
git config user.name
git config user.email

## github에 등록(잔디심기)
git add .
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/rudals5215/korit_07_java.git
git push -u origin main

강사 깃허브 아이디 : maybeags

git add .
git commit -m "feat: 20250729 scanner lesson"
git push