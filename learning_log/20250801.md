# 20250731

## 금일 복습 목록
- 목록
    1. Method (메서드)
       1) 메서드 정의 (복습)
       2) OverLoading
    2. class
# 1. Method (메서드)

## 정의 (복습)
Java에서는 함수 (function)의 개념과 돌일함.
JavaScript / Python에서는 function / method의 개념이 분리되어 있으나
Java는 모든 함수가 클래스에 종속되어있기 때문에 method로 통일

function vs method

근데 그러면 용어를 왜 분리하는가?

- 기본적으로 클래스 내부에 함수를 정의하게 되면 이를 '메서드'라고 합니다;.
  Java는 모든 함수들이 특정 클래스에 종속돼있기 떄문에 전부 다 매서드에 해당됩니다.

그래서 다른 언어를 배우게 된다면 '함수의 호출 방식'과'메서드의 호출 방식' 상에서의
차이가 존재하지만, 현재 저희 수업을 기준으로는 전부다 method에 해당하고,
이에 따라서 제가 Java수업 중인데 갑자기 함수 어쩌고하면 그냥 메서드라고 알아들으시면 됩니다.

하지만 추후에 차이가 생깁니다.

## 용어 정리
1. method 정의 (def - define) : 사용자가 메서드를 새로 만드는것을 의미
2. method 호출(call) : 만들어진(미리 만들어진) 메서드를 실행시키는 것을 의미
3. 매개변수(parameter) : 특정 메서드에 필수적으로 요구되어지는 변수
4. 출력값 / 결과값 / 리턴값(return) : 메서드의 호출 결과 생성되는 자료(없을수도 있음/output)
5. 인수 / 인자 (argument) : 사용자가 메서드에 전달하는 입력(input)

## Java 상에서의 method
예를 들어, '사진을 찍는다' 라는 행위에 대해서
1. 주머니에서 폰을 꺼내고
2. 잠금화면을 풀고
3. 카메라를 켜고
4. 사진을 찍고자 하는 대상에 폰을 조준하고,
5. 셔터를 누른다
   라는 과정이 존재합니다
   그런데 제가어제 설명했듯이 컴퓨터는 생각보다 너무 멍청하기 때문에 '사진을 찍는다'라고 명령을
   내리는것으로는 충분하지않고, 1-6까지의 명령어를 순서대로 입력해줘야만 합니다.
   하지만 매번 이렇게 하는 것이 번거롭기 때문에 우리는 '사진을 찍는다' 라는 일련의 동작을 하나의 메서드로
   이름을 붙이고, 그 내부에 1-6까지의 명령어를 미리 입력해 두는 과정을 거치게 되는데, 이를
   메서드 '정의' 라고 합니다.
   그리고 실제로 컴퓨터에게 '사진을 찍는다' 라는 명령을 내리게 되는것을 메서드 '호출' 이라는 표현이 됩니다.

그리고 여로러분의 폰이 아이폰인지 안드로이드폰인지에 따라서 잠금화면을 푸는 방식 등이 달라지겠죠.
그래서 특정한 폰을 지니고 있음을 컴퓨터에게 알릴 필요가 있을겁니다.
이를 argument라고 할 수있습니다.
그리고 사진을 찍으면 사진 결과물이 남겠죠
이것이 return에 해당하는 것이라고 볼 수 있겠습니다.

- 메서드 정의 
```java
public class Method01 {

    // 1. [ x | x ] [ 입력값 / 출력값]
    public static void call1() {
        System.out.println("[ x | x ]");
    }

    // 2, [ o | x ]
    public static void call2(String example) {       // (String example = 매개변수)
        System.out.println("[ o | x ]");
        System.out.println("영어인사 : " + example);
    }

    // 3. [ x | o ]                         // void - return값이 없다.
    public static String call3() {
        String example = "안녕하세요";
        System.out.println("[ x | o ]");
        return example;
    }

    // 4. [ o | o ]
    public static double call4(double score) {
        System.out.println("[ o | o ]");
        System.out.println("해당 과목은 3학점 짜리입니다.");
        return score * 3;
    }
}
```
return이 있는 이유는 기본적으로 데이터의 조작을 위해서 입니다. 그래고 특정 메서드의 결과값이
다른 메서드의 argument로 사용 될 수도 있습니다.

## 함수형 프로그래밍(Functional Programing)
메서드 1의 return 값이 메서드2의 argument가 되고 메서드2의 return값이 메서드3의 argument가 되는 방식으로,
첫번째 메서드로부터 마지막 메서드까지의 흐름을 통해 프로그램이 이어지는 코드 방식

예시)
```java
public static String inteoduce(String name, int age){
        return "제 이름은" + name + "이고, 나이는 " + age + "살 입니다\n내년에는 " + (age + 1) + "살이 됩니다.";
    }
    public static void main(String[] args) {
        // 메서드 호출 영역
        call1();
        call2("hello");
        call3();

        // return값을 출력하기 위해서는
        System.out.println(call3() + "!");
        String name = "김일";
        System.out.println(name + " 학생의 학점은 " + call4(4.5) + "입니다.");
        // return 값이있는 이유 = 추가적인 연산이 가능하기때문에 - 실행단계에서 데이터를 조작 가능

        Scanner scanner = new Scanner(System.in);
        String myName = "";
        int myAge = 0;
        System.out.print("이름을 입력하세요 >>> ");
        myName = scanner.nextLine();                
        // 사실 이 nextLine(); 이 메서드입니다. -> 메서드의 결과값을 myName 이라는 변수에 저장했습니다.
        System.out.print("나이를 입력하세요 >>> ");
        myAge = scanner.nextInt();
        System.out.println(inteoduce(myName, myAge));    
        // 그리고 그 myName / myAge라는 결과값을 우리가 정의한 introduce() 메서드의 argument로 사용하여 최종 결과물을 콘솔에 출력합니다.
    }
```

예시2) 별찍기
```java
    // call4() 유형으로 작성할예정 -> 몇 줄 짜리인지 / 어떤유형의 별찍기인지를 main에서 받을 예정이기 때문에
    public static String getStar(int rows,int option){
        // 메서드 내에서만 사용되는 지역 변수 (local variable) 선언 및 초기화
        String result = "";
        // 이 사이에 별찍기 관련로직이 들어갈 예정
        // 이제 주의할 점은 sout이 아니라 return 타입이 고정되어있다는 점 입니다.
        // 이 때문에 별찍기 로직을 그대로 가져오기는 하지만 sout으로 출력해서는 안됩니다.
        if (option == 1) {
            for(int i = 0; i < rows + 1 ; i++){
                for(int j = 0 ; j < i ; j++){
                    result += "*";
//                    System.out.print("*");      // 근데 이렇게 method내에 sout때렸을 때의 문제점 -> 데이터의 수정이 불가
                }
                // 개행을 책임지는 부분
                result += "\n";
            }

        } else if (option == 2){
            for(int i = 0; i < rows ; i++) {
                // 공백관련 for문
                for (int j = 0; j < rows - (i+1); j++) {
                    result += " ";
                }
                // 별찍기 관련 for문
                for (int k = 0 ; k < i + 1 ; k++){
                    result += "*";
                }
                result += "\n";
            }

        } else if (option == 3) {
            for(int i = rows; i > 0 ; i--) {
                for (int j = 0; j < i; j++) {
                    result += "*";
                }
                result += "\n";
            }
//            강사님 풀이
//            for(int i = 0; i < rows ; i++) {
//                for (int j = rows; j > i; j--) {
//                    result += "*";
//                }
//                result += "\n";
//            }

        } else if (option == 4) {
            for(int i = 0; i < rows ; i++) {
                for (int j = 0; j < i+1 ; j++) {
                    result += " ";
                }
                for (int k = rows ; k > i ; k--){
                    result += "*";
                }
                result += "\n";
            }
        } else {
            result = "해당 기능이 없습니다.";
        }
        
        return result;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int rowOfStars = 0;
        int choice = 0;
        String starResult = "";

        System.out.print("몇 줄짜리 별을 생성할까요? >>> ");
        rowOfStars = scanner.nextInt();

        System.out.println("1. 왼쪽으로 치우친 증가하는 별");
        System.out.println("2. 오른쪽으로 치우친 증가하는 별");
        System.out.println("3. 왼쪽으로 치우친 감소하는 별");
        System.out.println("4. 오른쪽으로 치우친 감소하는 별");
        System.out.print("선택하세요 >>> ");
        choice = scanner.nextInt();

        starResult = getStar(rowOfStars, choice);

        System.out.println(starResult);

    }
``` 
## 중요하게 봐야하는 개념
영어(); 라고 되어있는 부분에서 괄호()가 있는 영단어/문장이 사실은 메서드였다는 점.
scanner.nextLine();
System.out.println("특정내용");
과 같은 식으로 저희가 여태까지 영어로 명령어를 쓰고 소괄호를 적용한 모든것들이
메서드와 관련된 부분이었고, 그래서 사실 잘 쓰고 있었던 것이기 때문에
낯설게 느끼시기 보다는 원리를 이해하는 과정이라고 받아들이자.

예시 3) Scanner를 이용한 별찍기
```java
public static String getStar(){
        String result = "";
        // method 내부에서 method를 호출하는 것이 가능합니다.
        Scanner scanner = new Scanner(System.in);
        // Method02에서 main 단계에 써둔 부분을 여기에 다 가지고 오면
        // getStar() 메서드를 호출하는 것만으로도 동일한 결과값이 나오지 않을까요

        int rows = 0;               // Method02 에서는 rowOfStars 썼지 않나요? -> 근데 getStar()에서 매개변수를 rows로 써서
        int option = 0;             // 수정하기 귀찮아서 그냥 이렇게 씁니다.
        System.out.println("몇 줄 짜리 별을 생성하시겠습니까? >>> ");
        rows = scanner.nextInt();
        System.out.println(rows);

        System.out.println("1. 왼쪽으로 치우친 증가하는 별");
        System.out.println("2. 오른쪽으로 치우친 증가하는 별");
        System.out.println("3. 왼쪽으로 치우친 감소하는 별");
        System.out.println("4. 오른쪽으로 치우친 감소하는 별");
        System.out.print("선택하세요 >>> ");
        option = scanner.nextInt();
        System.out.println(option);

        if (option == 1) {
            for(int i = 0; i < rows + 1 ; i++){
                for(int j = 0 ; j < i ; j++){
                    result += "*";
                }
                // 개행을 책임지는 부분
                result += "\n";
            }

        } else if (option == 2){
            for(int i = 0; i < rows ; i++) {
                // 공백관련 for문
                for (int j = 0; j < rows - (i+1); j++) {
                    result += " ";
                }
                // 별찍기 관련 for문
                for (int k = 0 ; k < i + 1 ; k++){
                    result += "*";
                }
                result += "\n";
            }

        } else if (option == 3) {
            for(int i = rows; i > 0 ; i--) {
                for (int j = 0; j < i; j++) {
                    result += "*";
                }
                result += "\n";
            }

        } else if (option == 4) {
            for(int i = 0; i < rows ; i++) {
                for (int j = 0; j < i+1 ; j++) {
                    result += " ";
                }
                for (int k = rows ; k > i ; k--){
                    result += "*";
                }
                result += "\n";
            }
        } else {
            result = "해당 기능이 없습니다.";
        }


        return result;
    }

    public static void main(String[] args) {
//        String starResult = "";
//        starResult = getStar();
//        System.out.println(starResult);

        System.out.println(getStar());      // 매서드 호출 결과를 print
    }
```
## overloading
- method overloading
매개변수의 유무 및 자료형의 차이, 개수의 차이를 나눠서
동일한 메서드 명을 지닌 메서드들을 정의할 수 있다.

make / product / manufacture ... 그리 많지 않다
즉, 메서드 명은 동일하고, 매개변수에 들어가는 자료형, 갯수를
달리하게 되면 서로 다른 메서드로 받아들임.

- overloading의 장점 :
    동일한 기능을 하는 메서드를 정의할 때 메서드 명이 필요한데.
    예를 들어 String 자료형끼리 연결해주는 메서드와
    int끼리의 합 연산을 하는 메서드를 나눈다고 가정했을 때,
    add,
    plus,
    connect 등의 메서드를 정의했다면
    다음 합 연산을 하는(예를 들어 double 자료형을 지니는)메서드 명을 정하는 것이 번거롭다.
    이러한 부분의 해결을
```java
public void add(String example1, String example2) {
        로직
    }
    
public void add(int example1, int example2) {
        로직
}

// 또는

public void add(String example1, String example2, String example3) {
        로직
}
// 와 같은 식으로 메서드 명을 동일하게 가져가면서 차이를 둘 수 있습니다.
```
예시)
```java
// call1() 유형
public static void add(){
    System.out.println("add()");
}
// overloading 적용
// call2() 유형으로 정의
public static void add(String s){
    System.out.println("add(String s)");
    System.out.println(s+"!");
}

// call2() 유형으로 작성 # 2
public static void add(int a, int b){
    System.out.println("add(int a, int b");     // 사실 얘랑
    System.out.println(a+b);                    // 얘는 overloading의 결과물이겠네요.
}

public static void add(int a ,String s){
    System.out.println("add(int a, String s)");
    System.out.println(a + " / " + s);
}

public static void add(String s , int a){
    System.out.println("add(String s, int a)");
    System.out.println(a + " / " + s);
}

public static void add(int a, int b, double c){
    System.out.println("int a, int b, double c");
    System.out.println("a + b + c" + (a + b + c));
}

public static void main(String[] args) {
    // 메서드 호출 영역
    add();
    add("안녕하세요!");
    add(1,2);
    add(8,"월 1일");
    add("월 1일",8);
    add(1,2,4.5);
}
```
예시 2) 점수들을 입력받아서 총합 및 평균을 내는 프로그램 작성

3 과목의 점수를 입력 받아서, 총합과 평균 점수를 콘솔창에 표시하시오.

실행 예
몇 과목의 점수를 입력하시겠습니까? >>> 3
1 과목의 점수를 입력하세요 >>> 100
2 과목의 점수를 입력하세요 >>> 90
3 과목의 점수를 입력하세요 >>> 95
총합은 285.0이며, 평균은 95.0입니다.

- 일반 형식
```java
public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        double sum = 0;
        double avg = 0;
        int numOfSubs = 0;


        System.out.print("몇 과목의 점수를 입력하시겠습니까? >>> ");
        numOfSubs = scanner.nextInt();
        for (int i = 0 ; i < numOfSubs; i++){
            System.out.print((i+1) + "과목의 점수를 입력하세요 >>> ");
            sum += scanner.nextDouble();
        }
        avg = sum / numOfSubs;
        System.out.println("총합은 " + sum + "이며, 평균은 "+ avg + "입니다.");
    }
```
- 메서드를 활용한 형식
```java
public static void calcSumAndAvg() {
        Scanner scanner = new Scanner(System.in);
        double sum = 0;
        double avg = 0;
        int numOfSubs = 0;

        System.out.print("몇 과목의 점수를 입력하시겠습니까? >>> ");
        numOfSubs = scanner.nextInt();
        for (int i = 0 ; i < numOfSubs; i++){
            System.out.print((i+1) + "과목의 점수를 입력하세요 >>> ");
            sum += scanner.nextDouble();
        }
        avg = sum / numOfSubs;
        System.out.println("총합은 " + sum + "이며, 평균은 "+ avg + "입니다.");

    }

    public static void main(String[] args) {
        // 메서드 호출 영역
        calcSumAndAvg();
    }
```
- 다른 클래스에서 사용 가능. 메서드는 정의의 영역이기 때문에 호출이 가능하다.
```java
    public static void main(String[] args) {
        ScoreCalc02.calcSumAndAvg();            
        Scanner scanner = new Scanner(System.in);
        scanner.nextInt();
    }
```

# class

# 생성자 관련 정리(롬복)
1. NoArgsConstructor - 기본생성자
2. RequiredArgsConstructor - 매개변수 생성자
3. AllArgsConstructor - 클래스의 전체 필드를 전부 요구하는 매개변수 생성자

method 구현 관련 정리 / 클래스 개념 - 구성요소 / 생성자 관련 부분을 정리하면 되겠습니다.